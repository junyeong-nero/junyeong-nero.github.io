---
layout: single
title:  "22.12.28 Today's Leetcode"
---


## 1962. Remove Stones to Minimize the Total (Medium)

piles에 있는 돌들을 반틈하는 과정을 반복해서 최소한의 돌 개수를 반환하는 문제.
처음에는 그냥 간단하게 정렬하고 가장 맨 처음 돌을 반토막 내고 다시 정렬하는 방식으로 하면 될거라고 생각했으나
마찬가지로 Time Exceeded 문제에 맞닥드렸다. 

```python
class Solution:

    def find_max(self, piles):
        index = 0
        for i in range(len(piles)):
            if piles[i] > piles[index]:
                index = i
        return (index, piles[index]) 

    def minStoneSum(self, piles: List[int], k: int) -> int:
        import math
        total = sum(piles)
        piles.sort(reverse=True)
        while k > 0:
            half = math.floor(piles[0] / 2)
            total -= half
            piles[0] -= half
            k -= 1
            if len(piles) > 1 and piles[0] < piles[1]:
                piles.sort(reverse=True)
        return total        
```

이러한 문제를 해결하는 방식은 Heap을 이용하는 것이다. 정말 오랜만에 들어보는 데이터구조인데, 학교에서 배웠긴 하지만
PS에 사용해본적이 없어서 까먹고 있었다. Heap을 이용한 풀이는 다음과 같다. 

```python
class Solution:
    def minStoneSum(self, piles: List[int], k: int) -> int:
        pq = [-x for x in piles]
        heapify(pq)
        for _ in range(k): heapreplace(pq, pq[0]//2)
        return -sum(pq)
```

음수로 변형한 이유는 floor을 좀더 빠르게 처리하기 위함이고 `heapreplace` 라는 함수를 이용해서 구현하였다.
