---
layout: single
title:  "22.12.16 Today's Leetcode"
---


## 55. Jump Game (Medium)

재귀함수와 DP를 이용하여 풀었으나, Time Exceeded가 떠버려서, 다른 방식으로 풀었다. 간단하게 마지막 인덱스에 도달 할 수 있는지만 
확인하면 되는것이기에 뒤쪽 인덱스부터 for문을 사용하여 마지막 인덱스에 도달 할 수 있는지 체크하였다.

```python
# DP를 이용한 풀이
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        dp = [False] * len(nums)
        return self.help(dp, 0, nums)

    def help(self, dp, index, nums: List[int]) -> bool:
        if index >= len(nums) - 1:
            return True
        if dp[index]:
            return True

        res = False        
        for i in range(1, nums[index] + 1):
            res |= self.help(dp, index + i, nums)

        dp[index] = res
        return dp[index]
```

```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        last_index = len(nums) - 1
        for i in range(last_index, -1, -1):
            if i + nums[i] >= last_index:
                last_index = i
        return last_index <= 0
```

## 1382. Balance a Binary Search Tree

우리가 수업에서 배웠던 AVL Tree와는 다른 balancing 방식이어서 생소했다.
원래는 right, left rotating 을 이용하거나 2-3 Tree에서 사용하는 방식을 이용했는데
이 문제의 핵심은 그냥 '모든 elements' 들이 Tree에만 들어가면 되기 때문에 간단하게 DFS를 이용해서 모든 원소를 배열에 담고,
그 배열을 Binary Search 하듯이 Tree를 다시 만들어서 반환하였다.

```python
class Solution:
	def balanceBST(self, root: TreeNode) -> TreeNode:
		v = []
		def dfs(node):
			if node:
				dfs(node.left)
				v.append(node.val)
				dfs(node.right)
		dfs(root)

		def bst(v):
			if not v:
				return None
			mid = len(v) // 2
			root = TreeNode(v[mid])
			root.left = bst(v[:mid])
			root.right = bst(v[mid + 1:])
			return root

		return bst(v)
```
