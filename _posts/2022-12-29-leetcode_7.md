```python
class Solution:

    def get_shortest(self, tasks):
        index = 0
        for i, task in enumerate(tasks):
            if tasks[i][1] < tasks[index][1]:
                index = i
            elif tasks[i][1] == tasks[index][1]:
                if tasks[i][2] < tasks[index][2]:
                    index = i
        return (index, tasks[index])


    def getOrder(self, tasks: List[List[int]]) -> List[int]:
        # sort with enqueue time and index the tasks
        n = len(tasks)
        for i, task in enumerate(tasks):
            task.append(i)
        tasks.sort(key=lambda x : x[0])

        res = []
        avail = []
        current = tasks[0][0]
        check = [False] * n
        check_num = 0
        while check_num < n:
            for i, task in enumerate(tasks):
                if not check[i] and task[0] <= current:
                    avail.append(task)
                    check[i] = True
                    check_num += 1
            # print(avail)
            index, process = self.get_shortest(avail)
            res.append(process[2])
            current += process[1]
            avail.pop(index)

        while len(avail) > 0:
            index, process = self.get_shortest(avail)
            res.append(process[2])
            current += process[1]
            avail.pop(index)
        return res
```
