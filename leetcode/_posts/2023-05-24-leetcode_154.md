---
layout: single
title: "23.05.24 Today's Leetcode"
tags: leetcode
categories: leetcode
---

## 2542. Maximum Subsequence Score (medium)

DFS Approach TLE at 12/28

```python
class Solution:
    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:
        n = len(nums1)
        res = 0

        @functools.lru_cache(None)
        def dfs(a, b, index, count):
            if count == 0:
                nonlocal res
                res = max(res, a * b)
                return
            for i in range(index, n):
                dfs(a + nums1[i], min(b, nums2[i]), i + 1, count - 1)
        
        dfs(0, math.inf, 0, k)

        return res
```

Approach with prefixSum

```python
class Solution:
    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:
        res, prefixSum, maxHeap = 0, 0, []
        # sorted with nums2, therefore no need to consider minimum value of subsequences of nums2
        # clever approach!
        for a, b in sorted(list(zip(nums1, nums2)), key=itemgetter(1), reverse=True):
            prefixSum += a
            heappush(maxHeap, a)
            if len(maxHeap) == k:
                res = max(res, prefixSum * b)
                prefixSum -= heappop(maxHeap)                               
        return res
```

## 2596. Check Knight Tour Configuration (medium)

```python
class Solution:
    def checkValidGrid(self, grid: List[List[int]]) -> bool:
        n = len(grid)
        d = [(0, 0)] * (n * n)
        for i in range(n):
            for j in range(n):
                num = grid[i][j]
                d[num] = (i, j)

        if d[0] != (0, 0):
            return False

        for i in range(n * n - 1):
            a, b = d[i], d[i + 1]
            if abs(a[0] - b[0]) * abs(a[1] - b[1]) != 2:
                return False

        # print(d)
        return True
```
