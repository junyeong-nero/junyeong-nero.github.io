---
layout: single
title: "23.03.27 Today's Leetcode"
tags: leetcode
categories: leetcode
---

## 64. Minimum Path Sum (medium)

DP Approach

```python
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        dp = [[math.inf for i in range(n)] for j in range(m)]
        dp[0][0] = grid[0][0]
        for x in range(m):
            for y in range(n):
                if x > 0:
                    dp[x][y] = min(dp[x][y], dp[x - 1][y] + grid[x][y])
                if y > 0:
                    dp[x][y] = min(dp[x][y], dp[x][y - 1] + grid[x][y])
        print(dp)
        return dp[-1][-1]
```

## 2304. Minimum Path Cost in a Grid (medium)

```python
class Solution:
    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        dp = [[math.inf for _ in range(n)] for j in range(m)]
        for i in range(n):
            dp[0][i] = grid[0][i]
        
        print(dp[0])
        for i in range(1, m):
            for j in range(n):
                for p in range(n):
                    dp[i][j] = min(dp[i][j], dp[i - 1][p] + moveCost[grid[i - 1][p]][j] + grid[i][j])

            # print(dp[i])
        return min(dp[-1])
```

## 174. Dungeon Game (hard)

```python
class Solution:
    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:
        m, n = len(dungeon), len(dungeon[0])
        dp = [[float('inf')] * (n + 1) for _ in range(m + 1)]
        dp[m - 1][n] = dp[m][n - 1] = 1
        for i in range(m - 1, -1, -1):
            for j in range(n - 1, -1, -1):
                dp[i][j] = max(min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j], 1)
        return dp[0][0]
```
