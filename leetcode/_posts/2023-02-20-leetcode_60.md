---
layout: single
title: "23.02.20 Today's Leetcode"
tags: leetcode
categories: leetcode
---

## 35. Search Insert Position (easy)

Binary Search

```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        start, end = 0, len(nums)
        while start < end:
            mid = (start + end) // 2
            temp = nums[mid]
            if temp == target:
                return mid
            elif temp < target:
                start = mid + 1
            elif temp > target:
                end = mid
        return start
```

## 653. Two Sum IV - Input is a BST (easy)

```python
class Solution:
    def findTarget(self, root: Optional[TreeNode], k: int) -> bool:
        db = set()
        def dfs(node):
            if not node:
                return False
            target = k - node.val
            if target in db:
                return True
            db.add(node.val)
            res = False
            res |= dfs(node.left)
            res |= dfs(node.right)
            return res
        
        return dfs(root)
```

## 235. Lowest Common Ancestor of a Binary Search Tree (medium)

```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        road = set()
        ans = root
        temp = root
        while temp != p:
            if temp.val < p.val:
                temp = temp.right
            else:
                temp = temp.left
            road.add(temp)
        
        temp = root
        while temp != q:
            if temp.val < q.val:
                temp = temp.right
            else:
                temp = temp.left
            if temp in road:
                ans = temp
        return ans
```

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */

class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null) return null;
        if (root.val == p.val || root.val == q.val) return root;

        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        if (left != null && right != null) return root;
        if (left != null) return left;
        return right;
    }
}
```
